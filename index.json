[{
    "title": "Infrastructure as code using Terraform - Part 2",
    "date": "",
    "description": "Series of blog posts on Terraform.",
    "body": "Terraform Workspace Terraform Workspace provides you an option to create dedicated runtime stacks for each of your environments. For instance, the requirement is to create a Resource group based on project code for UAT and Prod environments. One of the ways to achieve this is using terraform workspace with a single code.\nA Workspace is created using terraform workspace new workspace_name. To list the workspace, you can use the \u0026ldquo;list\u0026rdquo; option. * indicates the current workspace. To switch to a different workspace, use the “select” option.\nPS C:\\content-management\\blog\u0026gt; terraform workspace new prod Created and switched to workspace \u0026#34;prod\u0026#34;! You\u0026#39;re now on a new, empty workspace. Workspaces isolate their state, so if you run \u0026#34;terraform plan\u0026#34; Terraform will not see any existing state for this configuration. PS C:\\content-management\\blog\u0026gt; terraform workspace list default * prod In this example, I am creating the resource group based on the workspace, i.e., Prod and UAT. I am using the local variable to achieve this. The result would be two resource groups Prod-XYZ and UAT-XYZ . The sample code is enclosed below.\nvariable \u0026#34;ProjectCode\u0026#34; { type = string default = \u0026#34;XYZ\u0026#34; } variable \u0026#34;location\u0026#34; { type = string default = \u0026#34;eastus\u0026#34; } locals { RG = \u0026#34;${terraform.workspace}-${var.ProjectCode}\u0026#34; } Code for actual resource creation based on Workspace .\nresource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;RGname\u0026#34; { name = local.RG location = var.location } Result post running the code in Prod and UAT workspace\nPS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; terraform apply .\\uat.tfplan\razurerm_resource_group.RGname: Creating...\razurerm_resource_group.RGname: Creation complete after 3s [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ]\rApply complete! Resources: 1 added, 0 changed, 0 destroyed.\rThe state of your infrastructure has been saved to the path below. This state is required to modify and destroy your infrastructure, so keep it safe. To inspect the complete state\ruse the `terraform show` command.\rState path: terraform.tfstate\rPS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; PS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; terraform show\r# azurerm_resource_group.RGname:\rresource \u0026quot;azurerm_resource_group\u0026quot; \u0026quot;RGname\u0026quot; {\rid = \u0026quot;/subscriptions/XXXX/resourceGroups/UAT-XYZ\u0026quot;\rlocation = \u0026quot;eastus\u0026quot;\rname = \u0026quot;UAT-XYZ\u0026quot;\rtags = {}\r}\rPS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; Get-AzResourceGroup *XYZ | select ResourceGroupName\rResourceGroupName\r-----------------\rUAT-XYZ\rPROD-XYZ\rWhen you use destroy command within a workspace, all resources created in that stack are deleted. In the below example, I have run the destroy command on the UAT workspace.\nPS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; terraform workspace select UAT Switched to workspace \u0026#34;UAT\u0026#34;. PS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; terraform destroy azurerm_resource_group.RGname: Refreshing state... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ] An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: # azurerm_resource_group.RGname will be destroyed - resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;RGname\u0026#34; { - id = \u0026#34;/subscriptions/XXXX/resourceGroups/UAT-XYZ\u0026#34; -\u0026gt; null - location = \u0026#34;eastus\u0026#34; -\u0026gt; null - name = \u0026#34;UAT-XYZ\u0026#34; -\u0026gt; null - tags = {} -\u0026gt; null } Plan: 0 to add, 0 to change, 1 to destroy. Do you really want to destroy all resources in workspace \u0026#34;UAT\u0026#34;? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only \u0026#39;yes\u0026#39; will be accepted to confirm. Enter a value: yes azurerm_resource_group.RGname: Destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ] azurerm_resource_group.RGname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ, 10s elapsed] azurerm_resource_group.RGname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ, 20s elapsed] azurerm_resource_group.RGname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ, 30s elapsed] azurerm_resource_group.RGname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ, 40s elapsed] azurerm_resource_group.RGname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/UAT-XYZ, 50s elapsed] azurerm_resource_group.RGname: Destruction complete after 51s Destroy complete! Resources: 1 destroyed. PS D:\\Terraform\\blogLabs\\02-workspace\u0026gt; Get-AzResourceGroup *XYZ | select ResourceGroupName ResourceGroupName ----------------- PROD-XYZ ",
    "ref": "/blog/terraform02/"
  },{
    "title": "About Me",
    "date": "",
    "description": "Sharing is caring !!..",
    "body": "I am Shashi, I have been an IT Infrastructure engineer since 2008. I have worked predominately on virtualization, as the blog name indicates. I had an opportunity to work on multiple virtualization technologies, including VMware virtualization, Hyper V, Azure Cloud. Under the roof of security I have gained good experience in Symantec endpoint protection and Gemalto/ Thales encryption.\nCertifications:\n Microsoft Certified: Azure Solutions Architect Expert Exam AZ-303: Microsoft Azure Architect Technologies Exam 742: Identity with Windows Server 2016 VMware Certified Professional- Data Center Virtualization  Feel free to reach me in LinkedIn.\n",
    "ref": "/about/"
  },{
    "title": "Infrastructure as code using Terraform - Part 1",
    "date": "",
    "description": "Series of blog posts on Terraform.",
    "body": "Terraform Introduction Infrastructure as code, popularly known as IaC, adopted by industry through DevOps, the key reason being source code would always generate the same result. Infrastructure as code evolved to solve the problem of environment drift in the release pipelines. Inconsistency among environments leads to issues during deployments. Without IaC, administration and infrastructure maintenance involves manual processes that are hard to track and contributed to errors.\nThe most popular tools used for Iac are Azure ARM and Terraform. As the name suggests, Azure ARM is intended for Azure Cloud infra; however, Terraform supports multi cloud Infrastructure, VMware, and on-prem Infrastructure. Both the tools have their advantage and disadvantages. In both cases, administrators needs to spend some time to understand the syntax and nuances.\nTerraform is a preferred tool for IaC as most organizations use more than one cloud to host their resources. Some of the advantages of Terraform are\n Ease of understanding Multi-cloud support Code versioning Statefile Workspace to separate different stacks Inbuilt dependency calculation Parallel execution capability One-click or auto deployments and decommissions  A typical Terraform code has the following components\n Variables Data Providers Resources Output  Let us go through a simple example of creating a resource group. What do we need first? Before you start coding, you need a valid Azure account and authorization to create the required resources. You can use either PowerShell, azure cloud shell. You can directly start coding in the local system or using the Azure cloud shell. In this post, I am using the visual studio editor.\nYou can follow the installation instructions at link\nUnder the variable section, define the Resource Group Name and location. {} indicate the actual value of the variables are in the VAR file. The point to remember here is the file name needs to be terraform.tfvars\n############################################################################# # VARIABLES ############################################################################# variable \u0026#34;RGname\u0026#34; {} variable \u0026#34;location\u0026#34; {} Example of Var File\nRGname = \u0026#34;test-group\u0026#34; location = \u0026#34;eastus\u0026#34; Provider is nothing but the plugin the Terraform needs to import before executing the code; in our case, it’s Azure. ~\u0026gt; indicated the azurerm version needs to be greater than 1.0\n############################################################################# # PROVIDERS ############################################################################# #Import Azure provider/plugin  provider “azurerm” { version = “~\u0026gt; 1.0.” } Resources is the section you would create the actual resource . Here we are stating resource group \u0026ldquo;Rname \u0026quot; with the resource type as “azurerm_resource_group,” . Name and the location are the two mandatory properties to create a resource group. Name is populated using the value of declared variable RGname, which is of type string with allowed special characters. Lets say your company has a mandatory rule to have all the resource names in lower case , this is where you use inbuilt terraform functions . The code would look like – “name = lower(var.RGname)”\n############################################################################# # RESOURCES ############################################################################# resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;Rname\u0026#34; { name = var.RGname location = var.location tags = { \u0026#34;BusinessUnit\u0026#34; = \u0026#34;Test\u0026#34; } } Output : this is where you display the resource group name and location\n############################################################################# # OUTPUTS ############################################################################# output \u0026#34;ResourceGroupname\u0026#34; { value = azurerm_resource_group.Rname.name } output \u0026#34;ResourceGrouplocation\u0026#34; { value = azurerm_resource_group.Rname.location } How to run your first azure terraform code\n Create a folder “Terraform.” Navigate to the newly created folder “blab” Save the code as main.tf Save your variable file as terraform.tfvar  First step to execute your code is - Run terraform init , which will load the plugins defined under providers section of the code\nPS D:\\Terraform\\blab\u0026gt; terraform init Initializing the backend... Initializing provider plugins... - Using previously-installed hashicorp/azurerm v1.44.0 Terraform has been successfully initialized! You may now begin working with Terraform. Try running \u0026#34;terraform plan\u0026#34; to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. PS D:\\Terraform\\blab\u0026gt; The next step is to run Terraform plan, which will draw out an execution plan. Terraform performs a refresh, and then determines what actions are necessary to achieve the desired state specified in the configuration files. This step will not modify or create any resources.\nPS D:\\Terraform\\blab\u0026gt; terraform plan -out .\\plan.tfplan Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # azurerm_resource_group.Rname will be created + resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;Rname\u0026#34; { + id = (known after apply) + location = \u0026#34;eastus\u0026#34; + name = \u0026#34;test-group\u0026#34; + tags = { + \u0026#34;BusinessUnit\u0026#34; = \u0026#34;Test\u0026#34; } } Plan: 1 to add, 0 to change, 0 to destroy. Changes to Outputs: + ResourceGrouplocation = \u0026#34;eastus\u0026#34; + ResourceGroupname = \u0026#34;test-group\u0026#34; ------------------------------------------------------------------------ This plan was saved to: .\\plan.tfplan To perform exactly these actions, run the following command to apply: terraform apply \u0026#34;.\\\\plan.tfplan\u0026#34; The final step is to run Terraform apply to execute the plan which was drawn in the previous step.\nPS D:\\Terraform\\blab\u0026gt; terraform apply \u0026#34;.\\\\plan.tfplan\u0026#34; azurerm_resource_group.Rname: Creating... azurerm_resource_group.Rname: Creation complete after 2s [id=/subscriptions/XXXXX/resourceGroups/test-group] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. The state of your infrastructure has been saved to the path below. This state is required to modify and destroy your infrastructure, so keep it safe. To inspect the complete state use the `terraform show` command. State path: terraform.tfstate Outputs: ResourceGrouplocation = eastus ResourceGroupname = test-group Validate if your script has created the required resource group\nPS D:\\Terraform\\blab\u0026gt; Get-AzResourceGroup test* | select ResourceGroupName ResourceGroupName ----------------- test-group Now , lets explore the option to delete the resources created by terraform. Terraform uses state file to destroy all the resource\u0026rsquo;s in the current stack\nPS D:\\Terraform\\blab\u0026gt; ls Directory: D:\\Terraform\\blab Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 08-03-2021 15:06 .terraform -a--- 08-03-2021 14:54 1293 main.tf -a--- 15-03-2021 17:31 1330 plan.tfplan -a--- 15-03-2021 17:34 899 terraform.tfstate -a--- 15-03-2021 17:34 156 terraform.tfstate.backup -a--- 08-03-2021 15:05 42 terraform.tfvars PS D:\\Terraform\\blab\u0026gt; terraform destroy azurerm_resource_group.Rname: Refreshing state... [id=/subscriptions/XXXX/resourceGroups/test-group] An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: # azurerm_resource_group.Rname will be destroyed - resource \u0026#34;azurerm_resource_group\u0026#34; \u0026#34;Rname\u0026#34; { - id = \u0026#34;/subscriptions/XXXX/resourceGroups/test-group\u0026#34; -\u0026gt; null - location = \u0026#34;eastus\u0026#34; -\u0026gt; null - name = \u0026#34;test-group\u0026#34; -\u0026gt; null - tags = { - \u0026#34;BusinessUnit\u0026#34; = \u0026#34;Test\u0026#34; } -\u0026gt; null } Plan: 0 to add, 0 to change, 1 to destroy. Changes to Outputs: - ResourceGrouplocation = \u0026#34;eastus\u0026#34; -\u0026gt; null - ResourceGroupname = \u0026#34;test-group\u0026#34; -\u0026gt; null Do you really want to destroy all resources? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only \u0026#39;yes\u0026#39; will be accepted to confirm. Enter a value: yes azurerm_resource_group.Rname: Destroying... [id=/subscriptions/XXXX/resourceGroups/test-group] azurerm_resource_group.Rname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/test-group, 10s elapsed]azurerm_resource_group.Rname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/test-group, 20s elapsed]azurerm_resource_group.Rname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/test-group, 30s elapsed]azurerm_resource_group.Rname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/test-group, 40s elapsed]azurerm_resource_group.Rname: Still destroying... [id=/subscriptions/XXXX/resourceGroups/test-group, 50s elapsed]azurerm_resource_group.Rname: Destruction complete after 51s Destroy complete! Resources: 1 destroyed. PS D:\\Terraform\\blab\u0026gt; Get-AzResourceGroup test* | select ResourceGroupName PS D:\\Terraform\\blab\u0026gt; ",
    "ref": "/blog/terraform/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
